"""Raster ray intersection via exact per-cell bilinear patch solving.

This module is intentionally self-contained and does not depend on the existing
mapping code in this repository.

Core idea
---------
Treat a DEM/raster as a *piecewise bilinear height field* over a regular (x, y)
grid. For each grid cell, the height surface is:

    z(u, v) = a + b*u + c*v + d*u*v,  u,v in [0, 1]

Intersecting a 3D ray with that surface inside one cell reduces to solving a
quadratic in the ray parameter `t`. To avoid brute-force checking all cells, we
walk the grid cells intersected by the ray's (x, y) projection using a 2D DDA
grid traversal (Amanatides & Woo style).

"Different coordinate systems"
------------------------------
The intersection routines work in a single Cartesian coordinate system
(typically meters). If your ray and raster are expressed in different CRSs, you
can:

1) Reproject the ray to the raster CRS (linearized; good for small extents), or
2) Transform both into a local Cartesian frame (e.g. ENU) before intersecting.

This file provides helper utilities for both via `pyproj` (CRS) and a small ENU
frame implementation (ECEF <-> ENU).
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import TYPE_CHECKING, Any, Literal

import numpy as np

if TYPE_CHECKING:  # pragma: no cover
    import pyproj
    import rasterio
    from affine import Affine

__all__ = [
    "BilinearPatchIntersection",
    "ENUFrame",
    "HeightField",
    "HeightFieldIntersection",
    "Ray",
    "RigidTransform",
    "heightfield_from_rasterio",
    "intersect_ray_bilinear_patch",
    "intersect_ray_heightfield_bilinear",
    "transform_points_crs",
    "transform_ray_crs_linearized",
    "transform_ray_rigid",
    "wgs84_geodetic_to_ecef",
]


ArrayLike = Any


def _as_float3(xyz: ArrayLike) -> np.ndarray:
    arr = np.asarray(xyz, dtype=np.float64).reshape(3)
    return arr


def _norm3(v: np.ndarray) -> float:
    return float(np.linalg.norm(v))


def _normalize3(v: np.ndarray) -> np.ndarray:
    n = _norm3(v)
    if n == 0.0:
        raise ValueError("Cannot normalize zero-length vector")
    return v / n


def _solve_quadratic_real(a: float, b: float, c: float, eps: float = 1e-15) -> list[float]:
    """Return sorted real roots of a*t^2 + b*t + c = 0."""
    if abs(a) < eps:
        if abs(b) < eps:
            return []
        return [(-c) / b]

    disc = b * b - 4.0 * a * c
    if disc < 0.0:
        if disc > -eps:
            disc = 0.0
        else:
            return []
    sqrt_disc = float(np.sqrt(disc))

    # More stable than the naive formula.
    if b >= 0.0:
        q = -0.5 * (b + sqrt_disc)
    else:
        q = -0.5 * (b - sqrt_disc)

    if q == 0.0:
        t0 = (-b) / (2.0 * a)
        return [t0]

    t0 = q / a
    t1 = c / q
    return [t0, t1] if t0 <= t1 else [t1, t0]


@dataclass(frozen=True, slots=True)
class Ray:
    """3D ray: p(t) = origin + t * direction."""

    origin: np.ndarray
    direction: np.ndarray

    @classmethod
    def from_arrays(
        cls,
        origin: ArrayLike,
        direction: ArrayLike,
        *,
        normalize_direction: bool = False,
    ) -> Ray:
        o = _as_float3(origin)
        d = _as_float3(direction)
        if normalize_direction:
            d = _normalize3(d)
        return cls(origin=o, direction=d)


@dataclass(frozen=True, slots=True)
class HeightField:
    """Regular grid of heights z(y, x) at grid *vertices*.

    `z` is indexed as `z[row, col]` with shape (ny, nx). Each grid vertex has
    world coordinates:

        x = x0 + col * dx
        y = y0 + row * dy
        z = z[row, col]

    Cells are the rectangles between vertices, thus there are (ny-1) x (nx-1)
    bilinear patches.
    """

    z: np.ndarray
    x0: float
    y0: float
    dx: float
    dy: float
    nodata: float | None = None

    def __post_init__(self) -> None:
        if self.z.ndim != 2:
            raise ValueError("z must be a 2D array (ny, nx)")
        if self.z.shape[0] < 2 or self.z.shape[1] < 2:
            raise ValueError("z must be at least 2x2 to define one cell")
        if not np.isfinite(self.dx) or not np.isfinite(self.dy):
            raise ValueError("dx/dy must be finite")
        if self.dx <= 0.0 or self.dy <= 0.0:
            raise ValueError("dx/dy must be positive (flip your data beforehand)")

    @property
    def ny(self) -> int:
        return int(self.z.shape[0])

    @property
    def nx(self) -> int:
        return int(self.z.shape[1])

    @property
    def n_cells_y(self) -> int:
        return self.ny - 1

    @property
    def n_cells_x(self) -> int:
        return self.nx - 1

    @property
    def x_min(self) -> float:
        return self.x0

    @property
    def y_min(self) -> float:
        return self.y0

    @property
    def x_max(self) -> float:
        return self.x0 + self.dx * (self.nx - 1)

    @property
    def y_max(self) -> float:
        return self.y0 + self.dy * (self.ny - 1)

    def cell_origin(self, cell_x: int, cell_y: int) -> tuple[float, float]:
        return (self.x0 + cell_x * self.dx, self.y0 + cell_y * self.dy)

    def cell_is_valid(self, cell_x: int, cell_y: int) -> bool:
        z00 = self.z[cell_y, cell_x]
        z10 = self.z[cell_y, cell_x + 1]
        z01 = self.z[cell_y + 1, cell_x]
        z11 = self.z[cell_y + 1, cell_x + 1]
        # `np.isnan()` is not defined for integer arrays; `isfinite()` works for
        # both float and int.
        if not (np.isfinite(z00) and np.isfinite(z10) and np.isfinite(z01) and np.isfinite(z11)):
            return False
        if self.nodata is None:
            return True
        nd = self.nodata
        return z00 != nd and z10 != nd and z01 != nd and z11 != nd


@dataclass(frozen=True, slots=True)
class HeightFieldIntersection:
    t: float
    point: np.ndarray
    cell: tuple[int, int]  # (cell_x, cell_y)
    uv: tuple[float, float]  # (u, v) within cell
    normal: np.ndarray


@dataclass(frozen=True, slots=True)
class BilinearPatchIntersection:
    """Intersection of a ray with a general 3D bilinear patch."""

    t: float
    point: np.ndarray
    uv: tuple[float, float]
    normal: np.ndarray


def _ray_slab_intersection_1d(
    o: float,
    d: float,
    slab_min: float,
    slab_max: float,
    *,
    eps: float,
) -> tuple[float, float] | None:
    if abs(d) < eps:
        if slab_min <= o <= slab_max:
            return (-np.inf, np.inf)
        return None
    t0 = (slab_min - o) / d
    t1 = (slab_max - o) / d
    return (t0, t1) if t0 <= t1 else (t1, t0)


def _lerp(a: float, p0: np.ndarray, p1: np.ndarray) -> np.ndarray:
    return p0 * (1.0 - a) + p1 * a


def intersect_ray_bilinear_patch(
    ray: Ray,
    p00: ArrayLike,
    p10: ArrayLike,
    p01: ArrayLike,
    p11: ArrayLike,
    *,
    t_min: float = 0.0,
    t_max: float = float("inf"),
    eps: float = 1e-12,
) -> BilinearPatchIntersection | None:
    """Exact ray intersection with a general 3D bilinear patch.

    The patch is defined by four corner points:
        (u,v) = (0,0)->p00, (1,0)->p10, (0,1)->p01, (1,1)->p11.
    """
    p00_ = _as_float3(p00)
    p10_ = _as_float3(p10)
    p01_ = _as_float3(p01)
    p11_ = _as_float3(p11)

    o = ray.origin
    d = ray.direction

    # Solve for candidate u values (the ray can hit the patch up to twice).
    a = float(np.dot(np.cross(p10_ - p00_, p01_ - p11_), d))
    c = float(np.dot(np.cross(p00_ - o, d), p01_ - p00_))
    b = float(np.dot(np.cross(p10_ - o, d), p11_ - p10_) - (a + c))

    u_candidates = _solve_quadratic_real(a, b, c)
    if not u_candidates:
        return None

    best: tuple[float, float, float] | None = None  # (t, u, v)

    for u in u_candidates:
        if not (0.0 <= u <= 1.0):
            continue

        # Iso-line for fixed u is a line segment in v: P(v) = uo + v * ud.
        uo = _lerp(u, p00_, p10_)
        ud = _lerp(u, p01_, p11_) - uo

        delta = uo - o
        perp = np.cross(d, ud)
        denom = float(np.dot(perp, perp))
        if denom == 0.0:
            continue

        # Determinants for v and t numerators: det([delta, d, perp]), det([delta, ud, perp])
        v_num = float(np.dot(delta, np.cross(d, perp)))
        t_num = float(np.dot(delta, np.cross(ud, perp)))

        if not (t_num > denom * eps):
            continue
        if not (0.0 <= v_num <= denom):
            continue

        v = v_num / denom
        t = t_num / denom
        if t < t_min or t > t_max:
            continue

        if best is None or t < best[0]:
            best = (t, float(u), float(v))

    if best is None:
        return None

    t, u, v = best
    # Patch point and normal.
    pu0 = _lerp(v, p00_, p01_)
    pu1 = _lerp(v, p10_, p11_)
    p = _lerp(u, pu0, pu1)

    dpdu = _lerp(v, p10_, p11_) - _lerp(v, p00_, p01_)
    dpdv = _lerp(u, p01_, p11_) - _lerp(u, p00_, p10_)
    n = np.cross(dpdu, dpdv)
    n_norm = _norm3(n)
    if n_norm > 0.0:
        n /= n_norm
    else:
        n[:] = 0.0

    return BilinearPatchIntersection(t=float(t), point=p, uv=(u, v), normal=n)


def _intersect_ray_cell_bilinear(
    hf: HeightField,
    ray: Ray,
    cell_x: int,
    cell_y: int,
    t_enter: float,
    t_exit: float,
    *,
    eps: float,
) -> HeightFieldIntersection | None:
    """Intersect ray with a single bilinear heightfield cell on [t_enter, t_exit]."""
    if t_exit < t_enter:
        return None

    z00 = float(hf.z[cell_y, cell_x])
    z10 = float(hf.z[cell_y, cell_x + 1])
    z01 = float(hf.z[cell_y + 1, cell_x])
    z11 = float(hf.z[cell_y + 1, cell_x + 1])

    a0 = z00
    b0 = z10 - z00
    c0 = z01 - z00
    d0 = z11 - z10 - z01 + z00

    x_i, y_j = hf.cell_origin(cell_x, cell_y)

    u0 = (ray.origin[0] - x_i) / hf.dx
    v0 = (ray.origin[1] - y_j) / hf.dy
    u1 = ray.direction[0] / hf.dx
    v1 = ray.direction[1] / hf.dy

    # z_surface(t) = s0 + s1*t + s2*t^2
    s0 = a0 + b0 * u0 + c0 * v0 + d0 * u0 * v0
    s1 = b0 * u1 + c0 * v1 + d0 * (u0 * v1 + u1 * v0)
    s2 = d0 * u1 * v1

    # f(t) = z_ray(t) - z_surface(t) = (o_z - s0) + t*(d_z - s1) - t^2*s2
    qa = -s2
    qb = float(ray.direction[2] - s1)
    qc = float(ray.origin[2] - s0)

    roots = _solve_quadratic_real(qa, qb, qc)
    if not roots:
        return None

    for t in roots:
        if t < t_enter - eps or t > t_exit + eps:
            continue

        x = float(ray.origin[0] + t * ray.direction[0])
        y = float(ray.origin[1] + t * ray.direction[1])
        u = (x - x_i) / hf.dx
        v = (y - y_j) / hf.dy

        if not (-eps <= u <= 1.0 + eps and -eps <= v <= 1.0 + eps):
            continue

        u_clip = float(np.clip(u, 0.0, 1.0))
        v_clip = float(np.clip(v, 0.0, 1.0))

        # Surface derivatives in (u, v) for the bilinear z(u, v)
        dz_du = b0 + d0 * v_clip
        dz_dv = c0 + d0 * u_clip

        # Parametric surface:
        # P(u,v) = [x_i + u*dx, y_j + v*dy, z(u,v)]
        # dP/du = [dx, 0, dz/du], dP/dv = [0, dy, dz/dv]
        n = np.array(
            [-hf.dy * dz_du, -hf.dx * dz_dv, hf.dx * hf.dy],
            dtype=np.float64,
        )
        n_norm = _norm3(n)
        if n_norm > 0.0:
            n /= n_norm
        else:
            n[:] = 0.0

        z = float(ray.origin[2] + t * ray.direction[2])
        p = np.array([x, y, z], dtype=np.float64)
        return HeightFieldIntersection(
            t=float(t),
            point=p,
            cell=(cell_x, cell_y),
            uv=(u_clip, v_clip),
            normal=n,
        )

    return None


def intersect_ray_heightfield_bilinear(
    hf: HeightField,
    ray: Ray,
    *,
    t_min: float = 0.0,
    t_max: float = float("inf"),
    max_steps: int = 2_000_000,
    eps: float = 1e-12,
) -> HeightFieldIntersection | None:
    """Intersect ray with a regular-grid bilinear heightfield.

    Returns the closest hit with `t >= t_min` (and `t <= t_max`), or ``None``.
    """
    if max_steps <= 0:
        raise ValueError("max_steps must be > 0")

    # Intersect ray with the heightfield XY extents (ignore Z for traversal).
    tx = _ray_slab_intersection_1d(ray.origin[0], ray.direction[0], hf.x_min, hf.x_max, eps=eps)
    if tx is None:
        return None
    ty = _ray_slab_intersection_1d(ray.origin[1], ray.direction[1], hf.y_min, hf.y_max, eps=eps)
    if ty is None:
        return None

    t_enter = max(tx[0], ty[0], t_min)
    t_exit = min(tx[1], ty[1], t_max)
    if t_enter > t_exit:
        return None

    # Find start cell.
    x_enter = float(ray.origin[0] + t_enter * ray.direction[0])
    y_enter = float(ray.origin[1] + t_enter * ray.direction[1])

    cell_x = int((x_enter - hf.x_min) / hf.dx)
    cell_y = int((y_enter - hf.y_min) / hf.dy)
    cell_x = min(max(cell_x, 0), hf.n_cells_x - 1)
    cell_y = min(max(cell_y, 0), hf.n_cells_y - 1)

    # DDA traversal setup for X.
    if ray.direction[0] > 0.0:
        step_x = 1
        next_x_boundary = hf.x_min + (cell_x + 1) * hf.dx
        t_next_x = (next_x_boundary - ray.origin[0]) / ray.direction[0]
        t_delta_x = hf.dx / ray.direction[0]
    elif ray.direction[0] < 0.0:
        step_x = -1
        next_x_boundary = hf.x_min + cell_x * hf.dx
        t_next_x = (next_x_boundary - ray.origin[0]) / ray.direction[0]
        t_delta_x = -hf.dx / ray.direction[0]
    else:
        step_x = 0
        t_next_x = float("inf")
        t_delta_x = float("inf")

    # DDA traversal setup for Y.
    if ray.direction[1] > 0.0:
        step_y = 1
        next_y_boundary = hf.y_min + (cell_y + 1) * hf.dy
        t_next_y = (next_y_boundary - ray.origin[1]) / ray.direction[1]
        t_delta_y = hf.dy / ray.direction[1]
    elif ray.direction[1] < 0.0:
        step_y = -1
        next_y_boundary = hf.y_min + cell_y * hf.dy
        t_next_y = (next_y_boundary - ray.origin[1]) / ray.direction[1]
        t_delta_y = -hf.dy / ray.direction[1]
    else:
        step_y = 0
        t_next_y = float("inf")
        t_delta_y = float("inf")

    t_curr = t_enter

    for _ in range(max_steps):
        if cell_x < 0 or cell_x >= hf.n_cells_x or cell_y < 0 or cell_y >= hf.n_cells_y:
            break

        t_cell_exit = min(t_next_x, t_next_y, t_exit)

        if hf.cell_is_valid(cell_x, cell_y):
            hit = _intersect_ray_cell_bilinear(
                hf,
                ray,
                cell_x,
                cell_y,
                t_curr,
                t_cell_exit,
                eps=eps,
            )
            if hit is not None:
                return hit

        if t_cell_exit >= t_exit:
            break

        # Step to next cell.
        if t_next_x < t_next_y:
            cell_x += step_x
            t_curr = t_next_x
            t_next_x += t_delta_x
        elif t_next_y < t_next_x:
            cell_y += step_y
            t_curr = t_next_y
            t_next_y += t_delta_y
        else:
            # Crosses a corner: advance both.
            cell_x += step_x
            cell_y += step_y
            t_curr = t_next_x
            t_next_x += t_delta_x
            t_next_y += t_delta_y

    return None


@dataclass(frozen=True, slots=True)
class RigidTransform:
    """Rigid transform p' = R p + t."""

    R: np.ndarray  # (3, 3)
    t: np.ndarray  # (3,)

    def __post_init__(self) -> None:
        if self.R.shape != (3, 3):
            raise ValueError("R must have shape (3, 3)")
        if self.t.shape != (3,):
            raise ValueError("t must have shape (3,)")

    @classmethod
    def from_matrix4(cls, m: ArrayLike) -> RigidTransform:
        mat = np.asarray(m, dtype=np.float64)
        if mat.shape != (4, 4):
            raise ValueError("Expected a 4x4 matrix")
        return cls(R=mat[:3, :3].copy(), t=mat[:3, 3].copy())

    def apply_point(self, p: ArrayLike) -> np.ndarray:
        p3 = _as_float3(p)
        return self.R @ p3 + self.t

    def apply_direction(self, v: ArrayLike) -> np.ndarray:
        v3 = _as_float3(v)
        return self.R @ v3

    def inverse(self) -> RigidTransform:
        r_inv = self.R.T
        t_inv = -(r_inv @ self.t)
        return RigidTransform(R=r_inv, t=t_inv)


def transform_ray_rigid(ray: Ray, tf: RigidTransform, *, normalize_direction: bool = False) -> Ray:
    o = tf.apply_point(ray.origin)
    d = tf.apply_direction(ray.direction)
    if normalize_direction:
        d = _normalize3(d)
    return Ray(origin=o, direction=d)


def transform_points_crs(
    xyz: ArrayLike,
    crs_from: str | pyproj.CRS,
    crs_to: str | pyproj.CRS,
    *,
    always_xy: bool = True,
) -> np.ndarray:
    """Transform 3D point(s) between CRSs using pyproj.

    Accepts shape (..., 3) and returns the same shape.
    """
    import pyproj

    pts = np.asarray(xyz, dtype=np.float64)
    if pts.shape[-1] != 3:
        raise ValueError("Expected points with last dimension 3")

    transformer = pyproj.Transformer.from_crs(crs_from, crs_to, always_xy=always_xy)
    x, y, z = transformer.transform(pts[..., 0], pts[..., 1], pts[..., 2])
    out = np.stack([x, y, z], axis=-1).astype(np.float64, copy=False)
    return out


def transform_ray_crs_linearized(
    ray: Ray,
    crs_from: str | pyproj.CRS,
    crs_to: str | pyproj.CRS,
    *,
    direction_distance: float = 1000.0,
    always_xy: bool = True,
    normalize_direction: bool = False,
) -> Ray:
    """Transform a ray between CRSs by linearizing the transform at the origin.

    This approximates the ray as a straight line in the target CRS by
    transforming:
      - the origin, and
      - a second point along the ray (origin + d_hat * direction_distance).

    For affine CRS transforms this is exact; for non-linear transforms (e.g.
    geographic <-> projected, ECEF <-> projected) it's a local approximation.
    """
    d_hat = _normalize3(ray.direction)
    p0 = ray.origin
    p1 = ray.origin + d_hat * float(direction_distance)

    p01 = np.stack([p0, p1], axis=0)
    p01_t = transform_points_crs(p01, crs_from, crs_to, always_xy=always_xy)

    o_t = p01_t[0]
    d_t = p01_t[1] - p01_t[0]
    if normalize_direction:
        d_t = _normalize3(d_t)
    return Ray(origin=o_t, direction=d_t)


def heightfield_from_rasterio(
    dataset: rasterio.DatasetReader,
    *,
    band: int = 1,
    nodata: float | None = None,
    mode: Literal["pixel_centers"] = "pixel_centers",
) -> HeightField:
    """Create a `HeightField` from a north-up, axis-aligned rasterio dataset.

    Current limitations:
    - Only non-rotated rasters are supported (Affine.b == Affine.d == 0).
    - Heights are taken from pixel centers (so there are (H-1)*(W-1) bilinear
      cells).
    """
    if mode != "pixel_centers":
        raise ValueError("Only mode='pixel_centers' is implemented")

    transform: Affine = dataset.transform
    if transform.b != 0.0 or transform.d != 0.0:
        raise NotImplementedError("Rotated/sheared rasters are not supported by this heightfield helper")

    z = dataset.read(band).astype(np.float64, copy=False)
    if z.ndim != 2:
        raise ValueError("Expected a single-band raster")

    if nodata is None:
        nodata = dataset.nodata

    # World coords of pixel center (0,0).
    x0 = float(transform.c + transform.a * 0.5)
    y0 = float(transform.f + transform.e * 0.5)
    dx = float(transform.a)
    dy = float(transform.e)

    ny, nx = z.shape

    # Normalize orientation so dx/dy are positive and indices increase with x/y.
    if dx < 0.0:
        z = np.fliplr(z)
        x0 = x0 + dx * (nx - 1)
        dx = -dx
    if dy < 0.0:
        z = np.flipud(z)
        y0 = y0 + dy * (ny - 1)
        dy = -dy

    return HeightField(z=z, x0=x0, y0=y0, dx=dx, dy=dy, nodata=nodata)


WGS84_A = 6378137.0
WGS84_F = 1.0 / 298.257223563
WGS84_E2 = WGS84_F * (2.0 - WGS84_F)


def wgs84_geodetic_to_ecef(lat_deg: float, lon_deg: float, h_m: float) -> np.ndarray:
    """Convert WGS84 geodetic (lat, lon, h) to ECEF XYZ (meters)."""
    lat = np.deg2rad(lat_deg)
    lon = np.deg2rad(lon_deg)

    sin_lat = float(np.sin(lat))
    cos_lat = float(np.cos(lat))
    sin_lon = float(np.sin(lon))
    cos_lon = float(np.cos(lon))

    n = WGS84_A / np.sqrt(1.0 - WGS84_E2 * sin_lat * sin_lat)

    x = (n + h_m) * cos_lat * cos_lon
    y = (n + h_m) * cos_lat * sin_lon
    z = (n * (1.0 - WGS84_E2) + h_m) * sin_lat

    return np.array([x, y, z], dtype=np.float64)


@dataclass(frozen=True, slots=True)
class ENUFrame:
    """Local tangent plane frame for converting between ECEF and ENU."""

    origin_ecef: np.ndarray
    R_ecef_to_enu: np.ndarray  # (3,3)

    @classmethod
    def from_geodetic_wgs84(cls, lat_deg: float, lon_deg: float, h_m: float) -> ENUFrame:
        origin = wgs84_geodetic_to_ecef(lat_deg, lon_deg, h_m)

        lat = np.deg2rad(lat_deg)
        lon = np.deg2rad(lon_deg)
        sin_lat = float(np.sin(lat))
        cos_lat = float(np.cos(lat))
        sin_lon = float(np.sin(lon))
        cos_lon = float(np.cos(lon))

        r = np.array(
            [
                [-sin_lon, cos_lon, 0.0],
                [-sin_lat * cos_lon, -sin_lat * sin_lon, cos_lat],
                [cos_lat * cos_lon, cos_lat * sin_lon, sin_lat],
            ],
            dtype=np.float64,
        )
        return cls(origin_ecef=origin, R_ecef_to_enu=r)

    @property
    def R_enu_to_ecef(self) -> np.ndarray:
        return self.R_ecef_to_enu.T

    def ecef_to_enu(self, xyz_ecef: ArrayLike) -> np.ndarray:
        p = _as_float3(xyz_ecef) - self.origin_ecef
        return self.R_ecef_to_enu @ p

    def enu_to_ecef(self, xyz_enu: ArrayLike) -> np.ndarray:
        p = _as_float3(xyz_enu)
        return self.R_enu_to_ecef @ p + self.origin_ecef

    def ecef_dir_to_enu(self, v_ecef: ArrayLike) -> np.ndarray:
        v = _as_float3(v_ecef)
        return self.R_ecef_to_enu @ v

    def enu_dir_to_ecef(self, v_enu: ArrayLike) -> np.ndarray:
        v = _as_float3(v_enu)
        return self.R_enu_to_ecef @ v
